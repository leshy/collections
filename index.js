// Generated by LiveScript 1.4.0
(function(){
  var subscriptionman2, async, _, h, Validator, Backbone, v, RemoteModel, settings, Core, ModelMixin, RemoteInterfaceMixin, subscriptionMan, EventMixin, UnresolvedRemoteModel, ReferenceMixin, RequestIdMixin, CachingMixin, LiveRemoteModel, LiveModelMixin, slice$ = [].slice;
  subscriptionman2 = require('subscriptionman2');
  async = require('async');
  _ = require('underscore');
  h = require('helpers');
  Validator = require('validator2-extras');
  Backbone = require('backbone4000');
  v = Validator.v;
  _.extend(exports, require('./remotemodel'));
  RemoteModel = exports.RemoteModel;
  settings = exports.settings = {};
  settings.model = {};
  Core = exports.Core = Backbone.Model.extend4000({
    initialize: function(){
      return this.settings = _.extend({}, settings, this.settings, this.get('settings'));
    }
  });
  ModelMixin = exports.ModelMixin = Backbone.Model.extend4000({
    initialize: function(){
      return this.models = {};
    },
    defineModel: function(name){
      var i$, superclasses, definition, coreModelClass;
      superclasses = 1 < (i$ = arguments.length - 1) ? slice$.call(arguments, 1, i$) : (i$ = 1, []), definition = arguments[i$];
      if (definition.defaults == null) {
        definition.defaults = {};
      }
      definition.defaults.collection = this;
      definition.defaults._t = name;
      coreModelClass = this.modelClass || RemoteModel;
      return this.models[name] = coreModelClass.extend4000.apply(coreModelClass, superclasses.concat(definition));
    },
    resolveModel: function(entry){
      var keys, tmp;
      keys = _.keys(this.models);
      if (keys.length === 0) {
        throw "I don't have any models defined";
      }
      if (keys.length === 1 || entry._t == null) {
        return this.models[_.first(keys)];
      }
      if (entry._t && (tmp = this.models[entry._t])) {
        return tmp;
      }
      throw "unable to resolve " + JSON.stringify(entry) + " " + _.keys(this.models).join(", ");
    },
    modelFromData: function(entry){
      return new (this.resolveModel(entry))(entry);
    },
    findModels: function(pattern, limits, callback, callbackDone){
      var this$ = this;
      return this.find(pattern, limits, function(err, entry){
        if (err) {
          return callback(err);
        } else {
          return callback(err, this$.modelFromData(entry));
        }
      }, callbackDone);
    },
    findModel: function(pattern, callback){
      var this$ = this;
      return this.findOne(pattern, function(err, entry){
        if (!entry || err) {
          return callback(err);
        } else {
          return callback(err, this$.modelFromData(entry));
        }
      });
    },
    fcall: function(name, args, pattern, realm, callback, callbackMulti){
      return this.findModel(pattern, function(err, model){
        if (model) {
          return model.remoteCallReceive(name, args, realm, callback, callbackMulti);
        } else {
          return callback('model not found');
        }
      });
    }
  });
  RemoteInterfaceMixin = exports.RemoteInterfaceMixin = Backbone.Model.extend4000({
    initialize: function(){
      var parsePermissions, this$ = this;
      parsePermissions = function(permissions){
        var def, parsePermission, keys;
        if (permissions) {
          def = false;
        } else {
          def = true;
        }
        parsePermission = function(permission){
          var x;
          switch (x = permission != null ? permission.constructor : void 8) {
          case undefined:
            return def;
          case Boolean:
            return permission;
          case Object:
            return h.dictMap(permission, function(value, key){
              if (key !== 'chew') {
                return v(value);
              } else {
                return value;
              }
            });
          default:
            throw "I don't know what to do with this " + permission;
          }
        };
        keys = {
          find: true,
          findOne: true,
          call: true,
          create: true,
          remove: true,
          update: true
        };
        return h.dictMap(keys, function(val, key){
          var permission, res;
          permission = permissions[key];
          if ((permission != null ? permission.constructor : void 8) === Array) {
            res = _.map(permission, parsePermission);
            return res;
          } else {
            return parsePermission(permission);
          }
        });
      };
      return this.permissions = parsePermissions(_.extend({}, this.permissions || {}, this.get('permissions') || {}));
    },
    applyPermissions: function(permissions, msg, realm, cb){
      var this$ = this;
      if (permissions.constructor !== Array) {
        return this.applyPermission(permissions, msg, realm, cb);
      }
      return async.series(_.map(permissions, function(permission){
        return function(cb){
          return this$.applyPermission(permission, msg, realm, function(err, data){
            return cb(data, err);
          });
        };
      }), function(data, err){
        if (!data) {
          return cb("Access Denied - Multi");
        } else {
          return cb(undefined, data);
        }
      });
    },
    applyPermission: function(permission, msg, realm, cb){
      var x, checkRealm, checkValue, checkChew;
      switch (x = permission != null ? permission.constructor : void 8) {
      case undefined:
        return cb("Access Denied - No Perm");
      case Boolean:
        if (permission) {
          return cb(void 8, msg);
        } else {
          return cb("Access Denied - Forbidden " + permission);
        }
        break;
      case Object:
        checkRealm = function(realm, cb){
          if (permission.realm != null) {
            return permission.realm.feed(realm, cb);
          } else {
            return _.defer(function(){
              return cb(void 8, msg);
            });
          }
        };
        checkValue = function(msg, cb){
          if (permission.value != null) {
            return permission.value.feed(msg, cb);
          } else {
            return _.defer(function(){
              return cb(void 8, msg);
            });
          }
        };
        checkChew = function(msg, realm, cb){
          if (permission.chew != null) {
            return permission.chew(msg, realm, cb);
          } else {
            return _.defer(function(){
              return cb(void 8, msg);
            });
          }
        };
        return checkRealm(realm, function(err, data){
          if (err) {
            return cb("Access Denied - Realm");
          }
          return checkValue(msg, function(err, msg){
            if (err) {
              return cb("Access Denied - Value");
            }
            return checkChew(msg, realm, function(err, msg){
              if (err) {
                return cb("Access Denied - Chew");
              }
              return cb(void 8, msg);
            });
          });
        });
      }
    },
    rCreate: curry$(function(realm, msg, callback){
      var this$ = this;
      return this.applyPermissions(this.permissions.create, msg, realm, function(err, msg){
        var modelClass, newModel;
        if (err) {
          return callback(err);
        }
        modelClass = this$.resolveModel(msg);
        newModel = new modelClass();
        newModel.update(msg, realm, function(err, data){
          if (err) {
            return callback(err);
          }
          return this$.eventAsync('remoteCreate', {
            data: data,
            model: newModel,
            realm: realm
          }, function(err, subChanges){
            subChanges == null && (subChanges = {});
            if (err) {
              return h.cbc(callback, err);
            }
            subChanges = _.reduce(subChanges, function(all, data){
              return _.extend(all, data);
            }, {});
            newModel.set(subChanges);
            return newModel.flush(function(err, data){
              if (err) {
                return callback(err);
              } else {
                return newModel.render(realm, function(err, data){
                  if (err) {
                    return callback(err);
                  } else {
                    return callback(void 8, data);
                  }
                });
              }
            });
          });
        });
        return newModel.flush(function(err, data){
          return h.cbc(callback, err, data);
        });
      });
    }),
    rRemove: function(realm, msg, callback){
      var this$ = this;
      return this.applyPermissions(this.permissions.remove, msg, realm, function(err, pattern){
        var queue;
        if (err) {
          return callback(err);
        }
        queue = new h.queue({
          size: 3
        });
        return this$.findModels(msg, {}, function(err, model){
          return queue.push(model.id, function(callback){
            return model.remove(callback);
          });
        }, function(err, data){
          return queue.done(callback);
        });
      });
    },
    rUpdate: function(realm, msg, callback){
      var this$ = this;
      return this.applyPermissions(this.permissions.update, msg, realm, function(err, msg){
        var queue;
        if (err) {
          return callback(err);
        }
        queue = new h.queue({
          size: 3
        });
        return this$.findModels(msg.pattern, {}, function(err, model){
          return queue.push(model.id, function(callback){
            var this$ = this;
            return model.update(msg.data, realm, function(err, data){
              if (err) {
                return callback(err, data);
              }
              return model.flush(function(err){
                if (err) {
                  return callback(err);
                }
                return model.render(realm, function(err, data){
                  if (err) {
                    return callback(err);
                  }
                  return callback(void 8, data);
                });
              });
            });
          });
        }, function(){
          return queue.done(callback);
        });
      });
    },
    rFindOne: function(realm, msg, callback){
      var this$ = this;
      return this.applyPermissions(this.permissions.findOne, msg, realm, function(err, pattern){
        if (err) {
          return callback(err);
        }
        return this$.findOne(pattern, function(err, entry){
          if (!entry || err) {
            return callback(err);
          } else {
            return this$.modelFromData(entry).render(realm, function(err, data){
              if (err) {
                return callback(err);
              } else {
                return callback(void 8, data);
              }
            });
          }
        });
      });
    },
    rFind: function(realm, msg, callback, callbackDone){
      var this$ = this;
      return this.applyPermissions(this.permissions.find, msg, realm, function(err, msg){
        console.log(this$.name(), "FIND", err, msg.pattern);
        if (err) {
          return callback(err);
        }
        return this$.find(msg.pattern, msg.limits || {}, function(err, entry){
          console.log(this$.name(), "GOT", err, entry);
          if (err) {
            return callback(err);
          }
          return this$.modelFromData(entry).render(realm, callback);
        }, function(){
          console.log(this$.name(), "DONE");
          return callbackDone();
        });
      });
    },
    rCall: function(realm, msg, callback, callbackMulti){
      var this$ = this;
      return this.applyPermissions(this.permissions.call, msg, realm, function(err, msg){
        if (err) {
          return callback(err);
        }
        return this$.findModel(msg.pattern, function(err, model){
          if (model) {
            return model.remoteCallReceive(msg.name, msg.args, realm, callback, callbackMulti);
          } else {
            return callback('model not found');
          }
        });
      });
    }
  });
  subscriptionMan = subscriptionman2.Core.extend4000(subscriptionman2.asyncCallbackReturnMixin, subscriptionman2.simplestMatcher);
  EventMixin = exports.EventMixin = subscriptionMan.extend4000({
    create: function(data, callback){
      var this$ = this;
      return this.eventAsync('preCreate', data, function(err, subchanges){
        subchanges == null && (subchanges = {});
        if (err) {
          return h.cbc(callback, err);
        }
        subchanges = _.reduce(subchanges, function(all, data){
          return _.extend(all, data);
        }, {});
        if (data.id) {
          return h.cbc(callback, "can't specify id for new model");
        }
        return this$._super('create', _.extend(data, subchanges), function(err, data){
          return h.cbc(callback, err, data);
        });
      });
    }
  });
  exports.collectionDict = {};
  UnresolvedRemoteModel = exports.UnresolvedRemoteModel = Backbone.Model.extend4000({
    toString: function(){
      return "unresolved model " + this.id + " of collection " + this.collection.name();
    },
    initialize: function(){
      var this$ = this;
      this.when('id', function(id){
        return this$.id = id;
      });
      return this.when('collection', function(collection){
        this$.collection = collection;
        return this$.unset('collection');
      });
    },
    resolve: function(callback){
      var this$ = this;
      return this.collection.findOne({
        id: this.get('id')
      }, function(err, entry){
        if (!entry) {
          return callback('unable to resolve reference to ' + this$.get('id') + ' at ' + this$.collection.get('name'));
        } else {
          this$.morph(this$.collection.resolveModel(entry), _.extend(this$.attributes, entry));
          return h.cbc(callback, undefined, this$);
        }
      });
    },
    find: function(callback){
      return this.collection.findModel({
        id: this.get('id')
      }, callback);
    },
    morph: function(myclass, mydata){
      this.__proto__ = myclass.prototype;
      _.extend(this.attributes, mydata);
      this.initialize();
      return this.trigger('resolve');
    },
    del: function(callback){
      return this.trigger('del', this);
    },
    remove: function(callback){
      this.del();
      if (this.id) {
        return this.collection.remove({
          id: id
        }, h.cb(callback));
      } else {
        return h.cbc(callback);
      }
    },
    reference: function(){
      var ref;
      ref = _.extend({}, this.attributes);
      ref._r = ref.id;
      delete ref.id;
      ref._c = this.collection.name();
      delete ref.collection;
      return ref;
    }
  });
  ReferenceMixin = exports.ReferenceMixin = Backbone.Model.extend4000({
    initialize: function(){
      var this$ = this;
      this.collectionDict = exports.collectionDict;
      return this.when('name', function(name){
        return this$.collectionDict[name] = this$;
      });
    },
    getcollection: function(name){
      return this.collectionDict[name];
    },
    find: function(args, limits, callback, callbackDone){
      var this$ = this;
      return RemoteModel.prototype.exportReferences.call(RemoteModel.prototype, args, function(err, args){
        if (err) {
          return callbackDone(err);
        }
        return this$._super('find', args, limits, callback, callbackDone);
      });
    },
    findOne: function(args, callback){
      var this$ = this;
      return RemoteModel.prototype.exportReferences.call(RemoteModel.prototype, args, function(err, args){
        if (err) {
          return callbackDone(err);
        }
        return this$._super('findOne', args, callback);
      });
    },
    unresolved: function(data){
      if (!data.id && data._r) {
        data.id = data._r;
        delete data._r;
      }
      delete data._c;
      return new UnresolvedRemoteModel(_.extend(data, {
        collection: this
      }));
    },
    name: function(){
      return this.get('name');
    }
  });
  RequestIdMixin = exports.RequestIdMixin = Backbone.Model.extend4000({
    find: function(args, limits, callback, callbackDone){
      var uuid, this$ = this;
      uuid = JSON.stringify({
        name: this.name(),
        args: args,
        limits: limits
      });
      return this._super('find', args, limits, function(err, data){
        return callback(err, data, uuid);
      }, function(){
        return h.cbc(callbackDone, undefined, undefined, uuid);
      });
    },
    findOne: function(args, callback){
      var cb, this$ = this;
      cb = function(err, data){
        return callback(err, data, JSON.stringify({
          name: this$.name(),
          args: args
        }));
      };
      return this._super('findOne', args, cb);
    }
  });
  CachingMixin = exports.CachingMixin = Backbone.Model.extend4000({
    timeout: h.Minute,
    initialize: function(){
      this.cache = {};
      return this.timeouts = {};
    },
    addToCache: function(uuid, result, timeout){
      var name, this$ = this;
      if (!timeout) {
        timeout = this.timeout;
      }
      this.cache[uuid] = result;
      name = new Date().getTime();
      this.timeouts[name] = h.wait(timeout, function(){
        var ref$, ref1$;
        if (this$.timeouts[name]) {
          delete this$.timeouts[name];
        }
        if (this$.cache[uuid]) {
          return ref1$ = (ref$ = this$.cache)[uuid], delete ref$[uuid], ref1$;
        }
      });
      return result;
    },
    clearCache: function(){
      _.map(this.timeouts, function(f, name){
        return f();
      });
      this.timeouts = {};
      return this.cache = {};
    },
    findOne: function(args, callback){
      var uuid, loadCache, this$ = this;
      uuid = JSON.stringify({
        name: this.name(),
        args: args
      });
      if (loadCache = this.cache[uuid]) {
        callback(undefined, loadCache, uuid);
        return uuid;
      }
      this._super('findOne', args, function(err, data, uuid){
        var reqCache;
        reqCache = this$.addToCache(uuid, data);
        return callback(err, data, uuid, reqCache);
      });
      return uuid;
    },
    find: function(args, limits, callback, callbackDone){
      var uuid, loadCache, cache, fail, this$ = this;
      if (limits.nocache) {
        return this._super('find', args, limits, callback);
      }
      uuid = JSON.stringify({
        name: this.name(),
        args: args,
        limits: limits
      });
      if (loadCache = this.cache[uuid]) {
        _.map(loadCache, function(data){
          return callback(undefined, data, uuid);
        });
        h.cbc(callbackDone, undefined, undefined, uuid, loadCache);
        return uuid;
      }
      cache = [];
      fail = false;
      this._super('find', args, limits, function(err, data, uuid){
        var fail;
        if (!fail) {
          if (err) {
            fail = true;
          } else {
            cache.push(data);
          }
        }
        return callback(err, data, uuid);
      }, function(err, done, uuid){
        var reqCache;
        reqCache = this$.addToCache(uuid, cache);
        return h.cbc(callbackDone, err, done, uuid, reqCache);
      });
      return uuid;
    },
    update: function(filter, update, callback){
      this.clearCache();
      return this._super('update', filter, update, callback);
    },
    remove: function(data, callback){
      this.clearCache();
      return this._super('remove', data, callback);
    },
    create: function(data, callback){
      this.clearCache();
      return this._super('create', data, callback);
    }
  });
  LiveRemoteModel = RemoteModel.extend4000({
    references: 0,
    initialize: function(){
      return this.settings = this.collection.settings.model || {};
    },
    gCollectForce: function(){
      this.trigger('gCollectForce');
      return this.trigger('gCollect');
    },
    gCollect: function(){
      if (!--this.references) {
        return this.trigger('gCollect');
      }
    },
    newRef: function(){
      this.references++;
      return this;
    },
    flush: function(){
      var args;
      args = slice$.call(arguments);
      if (this.settings.autoGcollect) {
        this.gCollect();
      }
      return RemoteModel.prototype.flush.apply(this, args);
    },
    flushStay: function(){
      var args;
      args = slice$.call(arguments);
      return RemoteModel.prototype.flush.apply(this, args);
    },
    hold: function(callback){
      var model;
      model = this.collection.hold(this);
      return callback.call(model, function(){
        return model.gCollect();
      });
    }
  });
  LiveModelMixin = exports.LiveModelMixin = Backbone.Model.extend4000({
    initialize: function(){
      return this.liveModels = {};
    },
    modelClass: LiveRemoteModel,
    hold: function(model){
      var liveModel, this$ = this;
      if (liveModel = this.liveModels[model.id]) {
        return liveModel.newRef();
      } else {
        liveModel = this.liveModels[model.id] = model.newRef();
        liveModel.once('gCollect', function(){
          var ref$, key$, ref1$;
          return ref1$ = (ref$ = this$.liveModels)[key$ = model.id], delete ref$[key$], ref1$;
        });
        liveModel.trigger('live');
        return liveModel;
      }
    },
    modelFromData: function(entry){
      var liveModel;
      if (liveModel = this.liveModels[entry.id]) {
        return liveModel;
      } else {
        return ModelMixin.prototype.modelFromData.call(this, entry);
      }
    }
  });
  exports.classical = Core.extend4000(ModelMixin, ReferenceMixin, RequestIdMixin, CachingMixin);
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
